<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Debajit's Room</title>
    <link rel="icon" type="image/png" href="icon.png">
    <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: linear-gradient(135deg, #181818 0%, #232323 100%);
            min-height: 100vh;
        }
        #back-btn {
            position: fixed;
            top: 32px;
            left: 36px;
            width: 54px;
            height: 54px;
            background: rgba(0,0,0,0.18);
            border: none;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
            cursor: pointer;
            transition: background 0.2s;
        }
        #back-btn:hover {
            background: rgba(255,224,102,0.12);
        }
        #back-btn span {
            display: block;
            width: 28px;
            height: 28px;
            border-left: 4px solid #ffe066;
            border-bottom: 4px solid #ffe066;
            transform: rotate(45deg);
            margin-left: 8px;
        }
        #three-room {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }
    </style>
</head>
<body>
    <button id="back-btn" aria-label="Back to main">
        <svg viewBox="0 0 24 24" style="width: 22px; height: 22px; stroke: #ffe066; stroke-width: 2.5; fill: none;">
            <path d="M15 5l-7 7 7 7"/>
        </svg>
    </button>
    
    <!-- Background Music -->
    <audio id="bg-music" loop>
        <source src="music.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio>
    
    <!-- Music Control Button -->
    <button id="music-control" style="position: fixed; top: 32px; left: 100px; width: 48px; height: 48px; background: rgba(0,0,0,0.18); border: none; border-radius: 50%; display: flex; justify-content: center; align-items: center; z-index: 25; cursor: pointer; transition: background 0.2s;">
        <svg id="music-icon" width="24" height="24" viewBox="0 0 24 24" style="stroke: #ffe066; stroke-width: 2; fill: none;">
            <path d="M9 18V5l12-2v13"/>
            <circle cx="6" cy="18" r="3"/>
            <circle cx="18" cy="16" r="3"/>
        </svg>
    </button>
    
    <!-- Menu Button -->
    <button id="menu-btn" style="position: fixed; top: 32px; right: 36px; z-index: 25; background: none; border: none; cursor: pointer;">
        <!-- Hamburger Icon SVG -->
        <svg width="48" height="48" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
            <rect width="48" height="48" rx="24" fill="rgba(0,0,0,0.18)"/>
            <line x1="14" y1="18" x2="34" y2="18" stroke="#ffe066" stroke-width="3"/>
            <line x1="14" y1="30" x2="34" y2="30" stroke="#ffe066" stroke-width="3"/>
        </svg>
    </button>

    <div id="three-room"></div>
    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // Music Control Functionality
        const bgMusic = document.getElementById('bg-music');
        const musicControl = document.getElementById('music-control');
        const musicIcon = document.getElementById('music-icon');
        let musicPlaying = false;

        // Function to start music
        function startMusic() {
            // Restore volume from session storage
            const savedVolume = sessionStorage.getItem('musicVolume');
            if (savedVolume) {
                bgMusic.volume = parseFloat(savedVolume);
            } else {
                bgMusic.volume = 0.7;
            }
            
            // Always try to play music immediately
            bgMusic.play().then(() => {
                musicPlaying = true;
                updateMusicIcon();
            }).catch(error => {
                console.log('Music autoplay blocked:', error);
                // Show a message to user that they need to interact to start music
            });
        }

        // Function to toggle music
        function toggleMusic() {
            if (musicPlaying) {
                bgMusic.pause();
                musicPlaying = false;
                sessionStorage.setItem('musicPlaying', 'false');
            } else {
                bgMusic.play();
                musicPlaying = true;
                sessionStorage.setItem('musicPlaying', 'true');
            }
            updateMusicIcon();
        }

        // Function to update music icon
        function updateMusicIcon() {
            if (musicPlaying) {
                musicIcon.innerHTML = `
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                `;
            } else {
                musicIcon.innerHTML = `
                    <path d="M9 18V5l12-2v13"/>
                    <circle cx="6" cy="18" r="3"/>
                    <circle cx="18" cy="16" r="3"/>
                    <line x1="6" y1="6" x2="18" y2="18" stroke="#ffe066" stroke-width="2"/>
                `;
            }
        }

        // Add event listeners
        musicControl.addEventListener('click', toggleMusic);
        musicControl.addEventListener('mouseenter', () => {
            musicControl.style.background = 'rgba(255,224,102,0.12)';
        });
        musicControl.addEventListener('mouseleave', () => {
            musicControl.style.background = 'rgba(0,0,0,0.18)';
        });

        // Start music when page loads
        startMusic();

        document.getElementById('back-btn').onclick = () => {
            // Save current music state before navigating
            sessionStorage.setItem('musicPlaying', musicPlaying ? 'true' : 'false');
            sessionStorage.setItem('musicVolume', bgMusic.volume.toString());
            window.sessionStorage.setItem('fromRoom', '1');
            window.location.href = 'index.html';
        };
        // Three.js setup
        const container = document.getElementById('three-room');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x181818);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 1, 18); // Moved camera back further for bigger screens
        camera.fov = 65; // Adjusted FoV to reduce distortion
        camera.updateProjectionMatrix();
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Remove existing lights
        scene.children = scene.children.filter(child => !(child instanceof THREE.Light));
        
        // Basic lighting setup
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);

        const mainLight = new THREE.DirectionalLight(0xffffff, 1);
        mainLight.position.set(0, 10, 10);
        scene.add(mainLight);

        // Create movie screens
        const screens = [];
        const numScreens = 5;
        const screenWidth = 8; // Made screens significantly larger
        const spacing = 12;    // Increased spacing accordingly
        const totalWidth = spacing * numScreens; // Total width of all screens including gaps

        // Screen content configuration with image paths
        const screenConfigs = [
            { name: 'BLOG', type: 'blog', image: 'blog.jpg' },
            { name: 'HOME', type: 'home', image: 'home.jpg' },
            { name: 'CV', type: 'cv', image: 'resume.jpg' },
            { name: 'CONTACT', type: 'contact', image: 'contact.jpg' },
            { name: 'PROJECTS', type: 'projects', image: 'project.jpeg' }
        ];

        const textureLoader = new THREE.TextureLoader();

        // Create rounded rectangle shape
        function createRoundedRectShape(width, height, radius) {
            const shape = new THREE.Shape();
            shape.moveTo(-width/2 + radius, -height/2);
            shape.lineTo(width/2 - radius, -height/2);
            shape.quadraticCurveTo(width/2, -height/2, width/2, -height/2 + radius);
            shape.lineTo(width/2, height/2 - radius);
            shape.quadraticCurveTo(width/2, height/2, width/2 - radius, height/2);
            shape.lineTo(-width/2 + radius, height/2);
            shape.quadraticCurveTo(-width/2, height/2, -width/2, height/2 - radius);
            shape.lineTo(-width/2, -height/2 + radius);
            shape.quadraticCurveTo(-width/2, -height/2, -width/2 + radius, -height/2);
            return shape;
        }

        for (let i = 0; i < numScreens; i++) {
            const screenGroup = new THREE.Group();

            // Create the main display panel. The image will cover this shape.
            const displayWidth = screenWidth * 1.2;
            const displayHeight = screenWidth * 0.9;
            const displayShape = createRoundedRectShape(displayWidth, displayHeight, 0.3);
            const displayGeo = new THREE.ShapeGeometry(displayShape);

            const texture = textureLoader.load(screenConfigs[i].image, (tex) => {
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;

                const imageAspect = tex.image.width / tex.image.height;
                const displayAspect = displayWidth / displayHeight;

                if (imageAspect > displayAspect) {
                    tex.repeat.x = displayAspect / imageAspect;
                    tex.repeat.y = 1;
                    tex.offset.x = (1 - tex.repeat.x) / 2;
                    tex.offset.y = 0;
                } else {
                    tex.repeat.x = 1;
                    tex.repeat.y = imageAspect / displayAspect;
                    tex.offset.x = 0;
                    tex.offset.y = (1 - tex.repeat.y) / 2;
                }
            });

            const displayMat = new THREE.MeshStandardMaterial({
                map: texture,
                roughness: 0.6,
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            const display = new THREE.Mesh(displayGeo, displayMat);
            screenGroup.add(display);

            // Initial position - spread screens out more
            const xPos = (i - (numScreens - 1) / 2) * spacing;
            screenGroup.position.set(xPos, 1.5, 0); // Start higher up
            screenGroup.userData.type = screenConfigs[i].type;
            screenGroup.userData.initialX = xPos;
            screenGroup.userData.index = i;
            scene.add(screenGroup);
            screens.push(screenGroup);
        }

        // Add some fill lights to ensure visibility
        const fillLight1 = new THREE.PointLight(0xffffff, 0.3, 50);
        fillLight1.position.set(-5, 5, 8);
        scene.add(fillLight1);

        const fillLight2 = new THREE.PointLight(0xffffff, 0.3, 50);
        fillLight2.position.set(5, 5, 8);
        scene.add(fillLight2);

        // Click interaction
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        renderer.domElement.addEventListener('click', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            if (intersects.length > 0) {
                let screenGroup = intersects[0].object;
                while (screenGroup.parent && screenGroup.parent !== scene) {
                    screenGroup = screenGroup.parent;
                }
                
                if (screenGroup.userData.type === 'blog') {
                    sessionStorage.setItem('musicPlaying', musicPlaying ? 'true' : 'false');
                    sessionStorage.setItem('musicVolume', bgMusic.volume.toString());
                    window.location.href = 'blog.html';
                }
            }
        });

        // A simpler, more robust animation loop for the carousel
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const scrollSpeed = 0.8; // Adjust for a comfortable, continuous scroll

            screens.forEach((screen) => {
                // Move left at a constant speed
                screen.position.x -= scrollSpeed * delta;

                // Loop the screens around
                if (screen.position.x < -totalWidth / 2 - spacing) {
                    screen.position.x += totalWidth + spacing;
                }

                // --- Fading and scaling based on distance from center ---
                const dist = Math.abs(screen.position.x);
                const fadeStart = spacing * 1.5;
                const fadeEnd = spacing * 2.5;

                // Opacity: Fully visible near the center, fades out at the edges
                let opacity = 1.0;
                if (dist > fadeStart) {
                    opacity = Math.max(0, 1.0 - (dist - fadeStart) / (fadeEnd - fadeStart));
                }

                // Scale: Smaller at the edges, larger at the center
                const scale = 1.0 - Math.min(1, dist / fadeEnd) * 0.3;
                screen.scale.set(scale, scale, scale);
                
                // Apply opacity to all materials in the group
                screen.traverse((child) => {
                    if (child.isMesh && child.material) {
                        child.material.opacity = opacity;
                        child.material.transparent = true;
                    }
                });
            });

            renderer.render(scene, camera);
        }

        // Enhance hover effect
        renderer.domElement.addEventListener('mousemove', (event) => {
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            screens.forEach(screen => {
                // Reset hover effects
                screen.position.z = -Math.abs(screen.position.x) * 0.1;
                if (screen.children[2]) {
                    screen.children[2].material.emissiveIntensity = 0.2;
                }
            });

            if (intersects.length > 0) {
                let screenGroup = intersects[0].object;
                while (screenGroup.parent && screenGroup.parent !== scene) {
                    screenGroup = screenGroup.parent;
                }
                if (screens.includes(screenGroup)) {
                    // Enhanced hover effect
                    screenGroup.position.z = -Math.abs(screenGroup.position.x) * 0.1 + 0.5;
                    if (screenGroup.children[2]) {
                        screenGroup.children[2].material.emissiveIntensity = 0.8;
                    }
                    document.body.style.cursor = screenGroup.userData.type === 'blog' ? 'pointer' : 'default';
                }
            } else {
                document.body.style.cursor = 'default';
            }
        });

        animate();
    });
    </script>
</body>
</html> 